# pages/crypto_flagship.py
from __future__ import annotations
import os, time, math
from typing import Any, Dict, List
import streamlit as st
import pandas as pd
import plotly.graph_objs as go

# ---------- config ----------
def _api_base() -> str | None:
    # Streamlit Secrets first, then env
    base = getattr(st, "secrets", {}).get("API_BASE_URL") if hasattr(st, "secrets") else None
    return (base or os.getenv("API_BASE_URL") or os.getenv("HIS_API_BASE") or "").rstrip("/") or None

# ---------- backends ----------
def _post_forecast(base: str, arena: str, symbol: str, horizon: int) -> Dict[str, Any]:
    import requests
    r = requests.post(
        f"{base}/v1/forecast",
        json={"arena": arena, "symbol": symbol, "horizon": horizon},
        timeout=(3, 20),
    )
    r.raise_for_status()
    return r.json()

def _ccxt_ohlcv(symbol: str, limit: int = 500) -> pd.DataFrame | None:
    try:
        import ccxt
        ex = ccxt.binance({"enableRateLimit": True})
        mkt = symbol if symbol.endswith("USDT") else f"{symbol}USDT"
        data = ex.fetch_ohlcv(mkt, timeframe="1h", limit=limit)
        if not data:
            return None
        df = pd.DataFrame(data, columns=["ts","open","high","low","close","vol"])
        df["ts"] = pd.to_datetime(df["ts"], unit="ms")
        return df
    except Exception:
        return None

def _local_bands(series: pd.Series, horizon: int) -> Dict[str, Any]:
    closes = series.dropna().astype(float)
    # simple EWMA drift + vol band
    mu = closes.pct_change().ewm(span=50).mean().iloc[-1]
    sigma = closes.pct_change().ewm(span=50).std().iloc[-1]
    last = float(closes.iloc[-1])

    pts: List[Dict[str, Any]] = []
    for h in range(1, horizon + 1):
        drift = last * ((1 + mu) ** h)
        q = last * (sigma * math.sqrt(h) * 1.64)  # ~q90
        pts.append({"ts": int(time.time() + h*3600), "yhat": drift, "q10": drift - q, "q90": drift + q})

    entropy = float(min(1.0, max(0.0, sigma * 12)))
    edge = float(max(0.0, (mu - sigma/2)))
    regime = "EXPANSION" if mu > 0 and entropy < 0.5 else ("COMPRESSION" if entropy < 0.25 else "CHAOTIC")

    return {"event": {"arena":"crypto","symbol":"LOCAL","horizon":horizon,
                      "forecast":{"points":pts},
                      "metrics":{"entropy":entropy,"edge":edge,"regime":regime}}}

def _synthetic(symbol: str, horizon: int) -> Dict[str, Any]:
    now = int(time.time()); step = 3600
    base = 50000.0 if "BTC" in symbol.upper() else 3000.0
    vol = 0.012
    pts: List[Dict[str, Any]] = []
    for h in range(1, horizon+1):
        t = now + h*step
        drift = base * (1 + 0.01*math.sin(h/2.5))
        q = base * vol * math.sqrt(h) * 0.65
        pts.append({"ts": t, "yhat": drift, "q10": drift-q, "q90": drift+q})
    return {"event": {"arena":"crypto","symbol":symbol,"horizon":horizon,
                      "forecast":{"points":pts},
                      "metrics":{"entropy":0.31,"edge":0.06,"regime":"EXPANSION"}}}

# ---------- UI ----------
def show():
    st.subheader("ðŸ”¥ Crypto â€” Flagship")

    with st.expander("Settings", expanded=True):
        c1,c2,c3 = st.columns([2,3,2])
        with c1: symbol = st.text_input("Symbol", "BTCUSDT")
        with c2: horizon = st.slider("Horizon (hours)", 1, 48, 8)
        with c3: run = st.button("Run Forecast", use_container_width=True)

    if not run:
        st.info("Set your symbol & horizon then click **Run Forecast**.")
        return

    event = None

    # 1) Try backend
    base = _api_base()
    if base:
        try:
            res = _post_forecast(base, "crypto", symbol, horizon)
            event = res.get("event") or res
        except Exception as e:
            st.warning(f"Backend offline â†’ falling back to client mode. ({e})")

    # 2) Try client CCXT
    if event is None:
        df = _ccxt_ohlcv(symbol)
        if df is not None and not df.empty:
            event = _local_bands(df["close"], horizon)["event"]

    # 3) Synthetic last resort
    if event is None:
        event = _synthetic(symbol, horizon)["event"]

    pts = event["forecast"]["points"]
    dfp = pd.DataFrame(pts)
    dfp["ts"] = pd.to_datetime(dfp["ts"], unit="s", errors="coerce")

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=dfp["ts"], y=dfp["q90"], mode="lines", name="q90"))
    fig.add_trace(go.Scatter(x=dfp["ts"], y=dfp["q10"], mode="lines", name="q10", fill="tonexty"))
    fig.add_trace(go.Scatter(x=dfp["ts"], y=dfp["yhat"], mode="lines", name="yhat", line=dict(dash="dot")))
    fig.update_layout(height=420, margin=dict(l=10,r=10,t=10,b=10))
    st.plotly_chart(fig, use_container_width=True)

    m = event.get("metrics", {})
    a,b,c = st.columns(3)
    a.metric("Regime", m.get("regime","â€”"))
    b.metric("Entropy", f"{m.get('entropy',0):.2f}")
    c.metric("Edge", f"{m.get('edge',0):.3f}")

if __name__ == "__main__":
    show()
