import os, sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
# pages/crypto_flagship.py
from __future__ import annotations
import os, time, math, datetime as dt
from typing import Any, Dict, List
import requests
import pandas as pd
import plotly.graph_objs as go
import streamlit as st

# --- config helpers ---
def _api_base() -> str:
    # Prefer Streamlit Secrets â†’ fallback to env var
    base = (st.secrets.get("API_BASE_URL") or os.getenv("HIS_API_BASE") or "").strip()
    return base.rstrip("/")

def _call_backend(arena: str, symbol: str, horizon: int) -> Dict[str, Any] | None:
    base = _api_base()
    if not base:
        return None
    try:
        r = requests.post(
            f"{base}/v1/forecast",
            json={"arena": arena, "symbol": symbol, "horizon": horizon},
            timeout=(3, 25),
        )
        if r.status_code in (401, 402):
            # Paywall or auth â†’ let UI handle it
            st.warning("This arena requires a subscription. Use the Plans/Checkout button in the sidebar.")
            return None
        r.raise_for_status()
        return r.json()
    except Exception as e:
        st.info(f"Backend not reachable, using demo data. ({e})")
        return None

def _synthetic_forecast(symbol: str, horizon: int) -> Dict[str, Any]:
    now = dt.datetime.utcnow().replace(microsecond=0)
    pts: List[Dict[str, Any]] = []
    for i in range(horizon + 30):
        t = now + dt.timedelta(days=i)
        base = 100 + 5 * math.sin(i / 3.0)
        band = 2.0 + 0.25 * i
        pts.append({"ts": t.isoformat() + "Z", "yhat": base, "q10": base - band, "q90": base + band})
    return {
        "event": {
            "arena": "crypto",
            "symbol": symbol,
            "horizon": horizon,
            "forecast": {"points": pts},
            "metrics": {"entropy": 0.33, "edge": 0.12, "regime": "Compressionâ†’Expansion"},
        }
    }

def _plot_forecast(payload: Dict[str, Any]) -> go.Figure:
    ev = payload["event"]
    points = ev["forecast"]["points"]
    df = pd.DataFrame(points)
    df["ts"] = pd.to_datetime(df["ts"])

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df["ts"], y=df["q90"], mode="lines", name="q90", line=dict(width=0)))
    fig.add_trace(go.Scatter(x=df["ts"], y=df["q10"], mode="lines", name="q10", fill="tonexty"))
    fig.add_trace(go.Scatter(x=df["ts"], y=df["yhat"], mode="lines", name="Å·", line=dict(dash="dash")))
    fig.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        height=460,
        showlegend=False,
    )
    return fig

def show():
    st.subheader("ðŸ”¥ Crypto â€” Flagship")

    # Controls
    with st.expander("Settings", expanded=True):
        c1, c2, c3 = st.columns([2, 3, 2])
        with c1:
            symbol = st.text_input("Symbol", value="BTCUSDT")
        with c2:
            horizon = st.slider("Horizon (days)", 1, 30, value=5)
        with c3:
            run = st.button("Run Forecast", use_container_width=True)

    # Run
    if run:
        data = _call_backend("crypto", symbol, horizon) or _synthetic_forecast(symbol, horizon)
        ev = data["event"]
        m = ev.get("metrics", {})
        c1, c2, c3 = st.columns(3)
        c1.metric("Regime", m.get("regime", "â€”"))
        c2.metric("Entropy", f"{m.get('entropy', 0):.2f}")
        c3.metric("Edge", f"{m.get('edge', 0):.2f}")

        st.plotly_chart(_plot_forecast(data), use_container_width=True)

        st.caption(
            "If youâ€™re seeing demo bands, set **API_BASE_URL** in Streamlit Secrets to your FastAPI "
            "base (e.g., https://your-lipe-core.up.railway.app)."
        )
    else:
        st.info("Set a symbol & horizon, then click **Run Forecast**.")
