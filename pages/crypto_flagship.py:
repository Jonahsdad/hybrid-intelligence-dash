# pages/crypto_flagship.py
from __future__ import annotations
import os, time, math, random
from typing import Any, Dict, List
import requests
import pandas as pd
import streamlit as st
import plotly.graph_objects as go

def _api_base() -> str:
    # Streamlit Cloud: prefer Secrets; fall back to env
    return (st.secrets.get("HIS_API_BASE") or os.getenv("HIS_API_BASE") or "").rstrip("/")

def _forecast(arena: str, symbol: str, horizon: int) -> Dict[str, Any]:
    base = _api_base()
    if base:
        r = requests.post(
            f"{base}/v1/forecast",
            json={"arena": arena, "symbol": symbol, "horizon": horizon},
            timeout=(4, 25),
        )
        r.raise_for_status()
        return r.json()

    # ---------- synthetic fallback (demo mode) ----------
    now = int(time.time()); step = 60 * 60  # hourly points
    last = 50000.0
    vol  = 0.012
    pts: List[Dict[str, Any]] = []
    for h in range(1, horizon + 1):
        t  = now + h * step
        dr = 0.0004 * h
        yh = last * (1 + dr) * (1 + 0.01 * math.sin(h / 2.5))
        q  = last * vol * (h ** 0.5)
        pts.append({"ts": t, "yhat": yh, "q10": yh - q, "q90": yh + q})
    return {
        "event": {
            "arena": arena,
            "symbol": symbol,
            "horizon": horizon,
            "forecast": {"points": pts},
            "metrics": {"entropy": 0.31, "edge": 0.06, "regime": "EXPANSION", "mode": "DEMO"},
        }
    }

def show():
    st.subheader("ðŸ”¥ Crypto â€” Flagship")

    with st.expander("Settings", expanded=True):
        symbol  = st.text_input("Symbol", value="BTCUSDT")
        horizon = st.slider("Horizon", 1, 30, 5)
        run     = st.button("Run Forecast", use_container_width=True)

    if not run:
        base = _api_base()
        if base:
            st.caption(f"Connected to backend: {base}")
        else:
            st.warning("No backend configured (HIS_API_BASE). Running in demo mode with synthetic forecast.")
        return

    try:
        res = _forecast("crypto", symbol, horizon)
    except Exception as e:
        st.error(f"Forecast call failed: {e}")
        return

    evt = res.get("event", {})
    pts = (evt.get("forecast") or {}).get("points", [])
    if not pts:
        st.warning("No forecast points returned.")
        return

    df = pd.DataFrame(pts); df["t"] = pd.to_datetime(df["ts"], unit="s")

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df["t"], y=df["yhat"], mode="lines", name="yhat"))
    fig.add_trace(go.Scatter(x=df["t"], y=df["q10"],  mode="lines", name="q10",  line=dict(dash="dot")))
    fig.add_trace(go.Scatter(x=df["t"], y=df["q90"],  mode="lines", name="q90",  line=dict(dash="dot"), fill="tonexty"))
    fig.update_layout(margin=dict(l=10, r=10, t=30, b=10), height=420,
                      title=f"{symbol} â€¢ {horizon}-step forecast")
    st.plotly_chart(fig, use_container_width=True)

    m = evt.get("metrics", {})
    c1, c2, c3, c4 = st.columns(4)
    c1.metric("Entropy", f'{m.get("entropy", 0):.2f}')
    c2.metric("Edge",    f'{m.get("edge", 0):.2f}')
    c3.metric("Regime",  m.get("regime", "â€”"))
    c4.metric("Mode",    m.get("mode", "LIVE" if _api_base() else "DEMO"))
